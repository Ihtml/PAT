## 图的存储
### 邻接矩阵
设图G(V,E)的顶点标号为0, 1,.,N-1,那么可以令二维数组G[N][N]的两维分别表示图的顶点标号，即如果G[i][j]为1,则说明顶点i和顶点j之间有边;如果G[i][j]为0,则说明顶点i和顶点j之间不存在边，而这个二维数组G[][]则被称为邻接矩阵。另外，如果存在边权，则可以令G[i][i]存放边权，对不存在的边可以设边权为0、-1 或是一个很大的数。

### 邻接表
使用vector实现邻接表。
```c++
struct node {
    int v;                                  // 边的终点编号
    int w;                                  // 边权
    node(int _v, int _w) : v(_v), w(_w) {}  // 构造函数
};
vector<node> Adj[N];
Adj[1].push_back(node(3,4)); // 添加1号到达3号顶点的有向边，边权威4
```

## 图的遍历
### DFS
如果要遍历整个图，就需要对所有连通块分别进行遍历。所以DFS遍历图的基本思路就是将经过的顶点设置为已访问，在下次递归碰到这个顶点时就不再去处理，直到整个图的顶点都被标记为已访问。伪代码如下：
```c++
DFS(u) { //访问顶点 u
    vis[u] = true; //设置u 已被访问
    for (从u出发能到达的所有顶点v) //枚举从u出发可以到达的所有顶点 V
        if vis[v] == false //如果v未被访问
            DFS(v); //递归访问 v
}

DFSTrave(G) { //遍历图 G
    for (G的所有顶点u) //对 G的所有顶点u
        if vis[u]== false //如果 u未被访问
        DFS(u); //访问 u所在的连通块
}
```